name: Codeforces Auto Sync

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  sync_solutions:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml

      - name: Sync Codeforces Solutions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CF_HANDLE: ${{ secrets.CF_HANDLE }}
          CF_KEY: ${{ secrets.CF_KEY }}
          CF_SECRET: ${{ secrets.CF_SECRET }}
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          import time
          import hashlib
          import random
          import re
          from datetime import datetime
          from bs4 import BeautifulSoup

          cf_handle = os.environ.get('CF_HANDLE')
          cf_key = os.environ.get('CF_KEY')
          cf_secret = os.environ.get('CF_SECRET')

          if not cf_handle:
              print("‚ùå Missing Codeforces handle!")
              exit(1)

          print(f"üöÄ Starting sync for handle: {cf_handle}")
          print(f"üîë API Key present: {bool(cf_key)}")
          print(f"üîê API Secret present: {bool(cf_secret)}")

          # Create codeforces directory
          base_dir = './codeforces'
          os.makedirs(base_dir, exist_ok=True)
          print(f"üìÅ Created directory: {base_dir}")

          def generate_api_sig(method_name, params, api_secret):
              """Generate API signature for authenticated requests"""
              rand = str(random.randint(100000, 999999))
              params_str = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
              to_hash = f"{rand}/{method_name}?{params_str}#{api_secret}"
              api_sig = rand + hashlib.sha512(to_hash.encode()).hexdigest()
              return api_sig

          def get_user_submissions(handle, api_key=None, api_secret=None):
              """Get user submissions using Codeforces API"""
              method = "user.status"
              base_params = {"handle": handle}
              
              if api_key and api_secret:
                  print("üîê Using authenticated API request")
                  base_params["apiKey"] = api_key
                  base_params["time"] = str(int(time.time()))
                  api_sig = generate_api_sig(method, base_params, api_secret)
                  
                  params_list = [f"{k}={v}" for k, v in sorted(base_params.items())]
                  params_str = '&'.join(params_list)
                  url = f"https://codeforces.com/api/{method}?{params_str}&apiSig={api_sig}"
                  
                  response = requests.get(url)
              else:
                  print("üåê Using public API request (no authentication)")
                  url = "https://codeforces.com/api/user.status"
                  response = requests.get(url, params=base_params)
                  
              try:
                  response.raise_for_status()
                  data = response.json()
                  
                  if data['status'] == 'OK':
                      print(f"‚úÖ Successfully fetched {len(data['result'])} submissions")
                      return data['result']
                  else:
                      print(f"‚ùå API Error: {data.get('comment', 'Unknown')}")
                      return []
              except Exception as e:
                  print(f"‚ùå Error fetching submissions: {e}")
                  return []

          def scrape_submission_code(contest_id, submission_id, max_retries=3):
              """Scrape source code from a submission page with retries"""
              url = f"https://codeforces.com/contest/{contest_id}/submission/{submission_id}"
              
              headers = {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                  'Accept-Language': 'en-US,en;q=0.5',
                  'Connection': 'keep-alive',
                  'Upgrade-Insecure-Requests': '1'
              }
              
              for attempt in range(max_retries):
                  try:
                      session = requests.Session()
                      response = session.get(url, headers=headers, timeout=10)
                      response.raise_for_status()
                      
                      soup = BeautifulSoup(response.text, 'html.parser')
                      
                      # Method 1: Try to find pre tag with id
                      code_element = soup.find('pre', {'id': 'program-source-text'})
                      if code_element:
                          code = code_element.get_text()
                          if code.strip():
                              return code
                      
                      # Method 2: Try to find pre tag with class
                      code_element = soup.find('pre', class_='prettyprint')
                      if code_element:
                          code = code_element.get_text()
                          if code.strip():
                              return code
                      
                      # Method 3: Search for any pre tag containing code
                      all_pre = soup.find_all('pre')
                      for pre in all_pre:
                          code = pre.get_text()
                          if code.strip() and len(code) > 50:  # Likely actual code
                              return code
                      
                      print(f"‚ö†Ô∏è  No code found in HTML for submission {submission_id}")
                      
                  except requests.exceptions.RequestException as e:
                      print(f"‚ö†Ô∏è  Attempt {attempt + 1}/{max_retries} failed for {submission_id}: {e}")
                      if attempt < max_retries - 1:
                          time.sleep(2 ** attempt)  # Exponential backoff
                  except Exception as e:
                      print(f"‚ùå Error scraping submission {submission_id}: {e}")
                      break
              
              return None

          # Fetch submissions
          print(f"\nüì• Fetching submissions...")
          submissions = get_user_submissions(cf_handle, cf_key, cf_secret)
          
          if not submissions:
              print("‚ùå No submissions found or API error")
              exit(0)
          
          print(f"üìä Total submissions: {len(submissions)}")
          
          # Filter accepted submissions
          accepted_subs = [s for s in submissions if s.get('verdict') == 'OK']
          print(f"‚úÖ Accepted submissions: {len(accepted_subs)}")
          
          if not accepted_subs:
              print("‚ö†Ô∏è  No accepted submissions found!")
              exit(0)
          
          # Track processed problems
          processed_problems = {}
          success_count = 0
          fail_count = 0
          
          print(f"\nüîÑ Processing accepted submissions...\n")
          
          for idx, sub in enumerate(accepted_subs, 1):
              problem = sub['problem']
              contest_id = problem.get('contestId')
              
              if not contest_id:
                  continue
              
              problem_index = problem.get('index', '')
              problem_id = f"{contest_id}{problem_index}"
              
              # Skip if already processed
              if problem_id in processed_problems:
                  continue
              
              problem_name = problem.get('name', 'Unknown Problem')
              problem_rating = problem.get('rating', 'Unrated')
              tags = problem.get('tags', [])
              lang = sub['programmingLanguage']
              submission_id = sub['id']
              
              print(f"[{idx}/{len(accepted_subs)}] Processing: {problem_id} - {problem_name}")
              
              # Determine file extension
              ext_map = {
                  'GNU C++': 'cpp', 'GNU C++11': 'cpp', 'GNU C++14': 'cpp',
                  'GNU C++17': 'cpp', 'GNU C++20': 'cpp', 'GNU C++23': 'cpp',
                  'Clang++': 'cpp', 'MS C++': 'cpp',
                  'GNU C': 'c', 'GNU C11': 'c',
                  'Python 2': 'py', 'Python 3': 'py', 'PyPy 2': 'py', 'PyPy 3': 'py',
                  'Java 8': 'java', 'Java 11': 'java', 'Java 17': 'java', 'Java 21': 'java',
                  'Kotlin': 'kt', 'Scala': 'scala',
                  'JavaScript': 'js', 'Node.js': 'js',
                  'Go': 'go', 'Rust': 'rs',
                  'C#': 'cs', 'Mono C#': 'cs', '.NET': 'cs',
                  'Ruby': 'rb', 'PHP': 'php',
                  'Haskell': 'hs', 'Perl': 'pl', 'Dart': 'dart'
              }
              
              ext = 'txt'
              for key in ext_map:
                  if key in lang:
                      ext = ext_map[key]
                      break
              
              # Scrape source code
              code = scrape_submission_code(contest_id, submission_id)
              
              if code:
                  # Create folder
                  safe_name = re.sub(r'[^\w\s-]', '', problem_name.lower())
                  safe_name = re.sub(r'[-\s]+', '-', safe_name)
                  folder_name = f"{problem_id}-{safe_name}"
                  folder_path = os.path.join(base_dir, folder_name)
                  os.makedirs(folder_path, exist_ok=True)
                  
                  # Save source code
                  code_file = os.path.join(folder_path, f"solution.{ext}")
                  with open(code_file, 'w', encoding='utf-8') as f:
                      f.write(code)
                  print(f"  ‚úÖ Saved code: {code_file}")
                  
                  # Create README
                  readme_path = os.path.join(folder_path, 'README.md')
                  with open(readme_path, 'w', encoding='utf-8') as f:
                      f.write(f"# {problem_index}. {problem_name}\n\n")
                      f.write(f"**Contest ID:** {contest_id}\n\n")
                      f.write(f"**Rating:** {problem_rating}\n\n")
                      
                      if tags:
                          f.write(f"**Tags:** {', '.join(tags)}\n\n")
                      
                      f.write(f"**Problem Link:** [Codeforces](https://codeforces.com/problemset/problem/{contest_id}/{problem_index})\n\n")
                      f.write(f"**Submission Link:** [View Submission](https://codeforces.com/contest/{contest_id}/submission/{submission_id})\n\n")
                      f.write(f"**Language:** {lang}\n\n")
                      f.write(f"**Status:** Accepted ‚úÖ\n")
                  
                  processed_problems[problem_id] = {
                      'contest_id': contest_id,
                      'index': problem_index,
                      'name': problem_name,
                      'rating': problem_rating,
                      'tags': tags,
                      'lang': lang
                  }
                  
                  success_count += 1
              else:
                  print(f"  ‚ùå Failed to fetch code")
                  fail_count += 1
              
              # Rate limiting
              time.sleep(1.5)
          
          print(f"\n{'='*50}")
          print(f"‚úÖ Successfully processed: {success_count} problems")
          print(f"‚ùå Failed to fetch: {fail_count} problems")
          print(f"{'='*50}\n")
          
          # Create main README
          if processed_problems:
              main_readme_path = os.path.join(base_dir, 'README.md')
              with open(main_readme_path, 'w', encoding='utf-8') as f:
                  f.write(f"# üèÜ Codeforces Solutions - {cf_handle}\n\n")
                  f.write(f"**Total Problems Solved:** {len(processed_problems)}\n\n")
                  f.write(f"**Last Updated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}\n\n")
                  
                  # Group by rating
                  rating_groups = {}
                  for info in processed_problems.values():
                      rating = str(info['rating'])
                      rating_groups[rating] = rating_groups.get(rating, 0) + 1
                  
                  f.write("## üìä Problems by Rating\n\n")
                  for rating in sorted(rating_groups.keys(), key=lambda x: int(x) if x != 'Unrated' else 0):
                      f.write(f"- **{rating}:** {rating_groups[rating]} problems\n")
                  
                  f.write("\n## üìù All Problems\n\n")
                  
                  sorted_problems = sorted(
                      processed_problems.items(),
                      key=lambda x: (x[1]['contest_id'], x[1]['index'])
                  )
                  
                  for problem_id, info in sorted_problems:
                      safe_name = re.sub(r'[^\w\s-]', '', info['name'].lower())
                      safe_name = re.sub(r'[-\s]+', '-', safe_name)
                      folder_name = f"{problem_id}-{safe_name}"
                      f.write(f"- [{info['contest_id']}{info['index']} - {info['name']}](./{folder_name}) ")
                      f.write(f"(Rating: {info['rating']})\n")
              
              print(f"üìÑ Created main README: {main_readme_path}")
              print(f"\n‚úÖ Sync completed successfully!")
          else:
              print("\n‚ö†Ô∏è  No problems were processed")
          
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          if ! git diff --quiet --cached; then
            git commit -m "üîÑ Sync Codeforces solutions - $(date +'%Y-%m-%d')"
            git push
            echo "‚úÖ Changes pushed successfully!"
          else
            echo "‚ÑπÔ∏è  No changes to commit"
          fi
