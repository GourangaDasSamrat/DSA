name: Codeforces Auto Sync

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  sync_solutions:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml selenium-wire undetected-chromedriver

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@latest

      - name: Sync Codeforces Solutions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CF_HANDLE: ${{ secrets.CF_HANDLE }}
          CF_KEY: ${{ secrets.CF_KEY }}
          CF_SECRET: ${{ secrets.CF_SECRET }}
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          import time
          import hashlib
          import random
          import re
          from datetime import datetime
          from bs4 import BeautifulSoup

          cf_handle = os.environ.get('CF_HANDLE')
          cf_key = os.environ.get('CF_KEY')
          cf_secret = os.environ.get('CF_SECRET')

          if not cf_handle:
              print("‚ùå ERROR: CF_HANDLE secret not found!")
              print("Please add your Codeforces handle in GitHub Secrets")
              exit(1)

          print("="*60)
          print(f"üöÄ Codeforces Auto Sync Started")
          print(f"üë§ Handle: {cf_handle}")
          print(f"üîë API Key: {'‚úÖ Present' if cf_key else '‚ùå Not set'}")
          print(f"üîê API Secret: {'‚úÖ Present' if cf_secret else '‚ùå Not set'}")
          print("="*60)

          # Create codeforces directory
          base_dir = './codeforces'
          os.makedirs(base_dir, exist_ok=True)

          def generate_api_sig(method_name, params, api_secret):
              """Generate API signature"""
              rand = str(random.randint(100000, 999999))
              params_str = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
              to_hash = f"{rand}/{method_name}?{params_str}#{api_secret}"
              api_sig = rand + hashlib.sha512(to_hash.encode()).hexdigest()
              return api_sig

          def get_user_submissions(handle, api_key=None, api_secret=None):
              """Get submissions via API"""
              print(f"\nüì• Fetching submissions from API...")
              
              method = "user.status"
              base_params = {"handle": handle, "from": "1", "count": "100000"}
              
              if api_key and api_secret:
                  base_params["apiKey"] = api_key
                  base_params["time"] = str(int(time.time()))
                  api_sig = generate_api_sig(method, base_params, api_secret)
                  
                  params_list = [f"{k}={v}" for k, v in sorted(base_params.items())]
                  params_str = '&'.join(params_list)
                  url = f"https://codeforces.com/api/{method}?{params_str}&apiSig={api_sig}"
                  response = requests.get(url)
              else:
                  url = "https://codeforces.com/api/user.status"
                  response = requests.get(url, params=base_params)
              
              try:
                  data = response.json()
                  if data['status'] == 'OK':
                      submissions = data['result']
                      print(f"‚úÖ API Success: {len(submissions)} total submissions")
                      return submissions
                  else:
                      print(f"‚ùå API Error: {data.get('comment', 'Unknown error')}")
                      return []
              except Exception as e:
                  print(f"‚ùå Exception: {e}")
                  return []

          def fetch_code_aggressive(contest_id, submission_id, retries=5):
              """Aggressively fetch code with multiple methods"""
              
              # Method 1: Direct submission page
              url = f"https://codeforces.com/contest/{contest_id}/submission/{submission_id}"
              
              headers = {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                  'Accept-Language': 'en-US,en;q=0.9',
                  'Accept-Encoding': 'gzip, deflate, br',
                  'Connection': 'keep-alive',
                  'Upgrade-Insecure-Requests': '1',
                  'Cache-Control': 'max-age=0',
                  'Referer': 'https://codeforces.com/'
              }
              
              for attempt in range(retries):
                  try:
                      session = requests.Session()
                      time.sleep(1 + attempt * 0.5)  # Progressive delay
                      
                      response = session.get(url, headers=headers, timeout=15)
                      
                      if response.status_code == 200:
                          soup = BeautifulSoup(response.text, 'lxml')
                          
                          # Try multiple selectors
                          selectors = [
                              ('id', 'program-source-text'),
                              ('class', 'prettyprint'),
                              ('class', 'program-source'),
                          ]
                          
                          for selector_type, selector_value in selectors:
                              if selector_type == 'id':
                                  element = soup.find('pre', id=selector_value)
                              else:
                                  element = soup.find('pre', class_=selector_value)
                              
                              if element:
                                  code = element.get_text()
                                  if code and len(code.strip()) > 20:
                                      return code.strip()
                          
                          # Fallback: any substantial pre tag
                          all_pres = soup.find_all('pre')
                          for pre in all_pres:
                              text = pre.get_text().strip()
                              if len(text) > 50:
                                  return text
                      
                      elif response.status_code == 403:
                          print(f"      ‚ö†Ô∏è  Access denied (attempt {attempt+1})")
                      
                  except Exception as e:
                      print(f"      ‚ö†Ô∏è  Attempt {attempt+1} failed: {str(e)[:50]}")
              
              return None

          # Get submissions
          submissions = get_user_submissions(cf_handle, cf_key, cf_secret)

          if not submissions:
              print("\n‚ùå No submissions retrieved. Possible issues:")
              print("   1. Check if CF_HANDLE is correct")
              print("   2. Check if handle has any submissions")
              print("   3. API might be temporarily down")
              exit(0)

          # Filter accepted
          accepted = [s for s in submissions if s.get('verdict') == 'OK']
          print(f"‚úÖ Accepted submissions: {len(accepted)}")

          if not accepted:
              print("\n‚ö†Ô∏è  No accepted submissions found!")
              print(f"   Please verify: https://codeforces.com/profile/{cf_handle}")
              exit(0)

          # Process problems
          processed = {}
          stats = {'success': 0, 'failed': 0, 'skipped': 0}

          print(f"\n{'='*60}")
          print(f"üîÑ Processing {len(accepted)} accepted submissions...")
          print(f"{'='*60}\n")

          for idx, sub in enumerate(accepted, 1):
              problem = sub['problem']
              contest_id = problem.get('contestId')
              
              if not contest_id:
                  stats['skipped'] += 1
                  continue
              
              index = problem.get('index', '')
              problem_id = f"{contest_id}{index}"
              
              if problem_id in processed:
                  stats['skipped'] += 1
                  continue
              
              name = problem.get('name', 'Unknown')
              rating = problem.get('rating', 'Unrated')
              tags = problem.get('tags', [])
              lang = sub['programmingLanguage']
              sub_id = sub['id']
              
              print(f"[{idx:3d}/{len(accepted)}] {problem_id:8s} - {name[:40]:40s}", end=' ')
              
              # Extension mapping
              ext_map = {
                  'C++': 'cpp', 'C': 'c', 'Java': 'java', 'Python': 'py',
                  'Kotlin': 'kt', 'Rust': 'rs', 'Go': 'go', 'JavaScript': 'js',
                  'C#': 'cs', 'Ruby': 'rb', 'PHP': 'php', 'Scala': 'scala',
                  'Haskell': 'hs', 'Perl': 'pl', 'Dart': 'dart', 'Swift': 'swift'
              }
              
              ext = 'txt'
              for key, val in ext_map.items():
                  if key in lang:
                      ext = val
                      break
              
              # Fetch code
              code = fetch_code_aggressive(contest_id, sub_id)
              
              if code:
                  # Create folder
                  safe_name = re.sub(r'[^\w\s-]', '', name.lower())
                  safe_name = re.sub(r'[-\s]+', '-', safe_name)[:50]
                  folder_name = f"{problem_id}-{safe_name}"
                  folder_path = os.path.join(base_dir, folder_name)
                  os.makedirs(folder_path, exist_ok=True)
                  
                  # Save code
                  with open(os.path.join(folder_path, f"solution.{ext}"), 'w', encoding='utf-8') as f:
                      f.write(code)
                  
                  # Save README
                  with open(os.path.join(folder_path, 'README.md'), 'w', encoding='utf-8') as f:
                      f.write(f"# {index}. {name}\n\n")
                      f.write(f"**Contest:** {contest_id}\n")
                      f.write(f"**Rating:** {rating}\n")
                      if tags:
                          f.write(f"**Tags:** {', '.join(tags)}\n")
                      f.write(f"\n**Links:**\n")
                      f.write(f"- [Problem](https://codeforces.com/problemset/problem/{contest_id}/{index})\n")
                      f.write(f"- [Submission](https://codeforces.com/contest/{contest_id}/submission/{sub_id})\n")
                      f.write(f"\n**Language:** {lang}\n")
                      f.write(f"**Status:** ‚úÖ Accepted\n")
                  
                  processed[problem_id] = {
                      'contest': contest_id, 'index': index, 'name': name,
                      'rating': rating, 'tags': tags
                  }
                  
                  stats['success'] += 1
                  print("‚úÖ")
              else:
                  stats['failed'] += 1
                  print("‚ùå Failed")

          # Summary
          print(f"\n{'='*60}")
          print(f"üìä SUMMARY:")
          print(f"   ‚úÖ Success: {stats['success']}")
          print(f"   ‚ùå Failed:  {stats['failed']}")
          print(f"   ‚è≠Ô∏è  Skipped: {stats['skipped']}")
          print(f"{'='*60}")

          # Main README
          if processed:
              with open(os.path.join(base_dir, 'README.md'), 'w', encoding='utf-8') as f:
                  f.write(f"# üèÜ Codeforces Solutions - {cf_handle}\n\n")
                  f.write(f"**Problems Solved:** {len(processed)}\n")
                  f.write(f"**Last Sync:** {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}\n\n")
                  
                  ratings = {}
                  for p in processed.values():
                      r = str(p['rating'])
                      ratings[r] = ratings.get(r, 0) + 1
                  
                  f.write("## By Rating\n\n")
                  for r in sorted(ratings.keys(), key=lambda x: int(x) if x.isdigit() else 0):
                      f.write(f"- **{r}:** {ratings[r]}\n")
                  
                  f.write("\n## Problems\n\n")
                  for pid, info in sorted(processed.items(), key=lambda x: (x[1]['contest'], x[1]['index'])):
                      safe = re.sub(r'[^\w\s-]', '', info['name'].lower())
                      safe = re.sub(r'[-\s]+', '-', safe)[:50]
                      f.write(f"- [{pid} - {info['name']}](./{pid}-{safe}) ({info['rating']})\n")
              
              print(f"\n‚úÖ Created README with {len(processed)} problems")
          else:
              print("\n‚ö†Ô∏è  No problems successfully processed")

          print(f"\n{'='*60}")
          print("üèÅ Sync Complete!")
          print(f"{'='*60}\n")
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          if ! git diff --quiet --cached; then
            git commit -m "üîÑ Sync Codeforces - $(date +'%Y-%m-%d')"
            git push
            echo "‚úÖ Pushed to repository"
          else
            echo "‚ÑπÔ∏è  No new changes"
          fi
